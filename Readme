1,一个Linux内核模块主要由如下几个部分组成。
	1.1 模块加载函数（一般需要）
 		当通过insmod或modprobe 命令加载内核模块时，模块的加载函数会自动被内核执行，完成模块的相关初始化。
	1.2 模块卸载函数（一般需要）
 		当通过rmmod命令卸载模块时，模块的卸载函数会自动内内核执行，完成与模块卸载函数相反的功能。
 	1.3 模块许可证声明(必须)
		许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE,模块被加载时，将收到内核被污染（kernel tainted）的警告。
		MODULE_LINCENSE("Dual BSD/GPL")的语句声明模块采用BSD/GPL双LINCENSE。
	1.4 模块参数（可选）
		模块参数是模块被加载的时候可以被传递给它的值，它本身对应模块内部的全局变量。
	1.5 模块导出符号（可选）
		内核模块可以导出符号（symbol,对应于函数或变量），这样其他模块可以使用本模块中的变量或函数。
	1.6 模块作者等信息声明（可选）

2. Linux2.6 的 “proc/kallsyms”文件对应着内核符号表，它记录了符号以及符号所在的内存地址。
	模块可以使用如下宏到处符号到内核符号表：
	EXPORT_SYMBOL(符号名)；
	EXPORT_SYMBOL_GPL(符号名)；
	导出的符号将可以被其他模块使用，使用前声明一下即可，EXPORT_SYMBOL_GPL()只适用于包含GPL许可权的模块。

3. Linux 的文件系统
	1.创建
		int creat(const char *filename, mode_t mode);
		mode:指定新建文件的存取权限，它同umask一起决定文件的最终权限（mode&umask）
		umask可通过调用 int umask(int newmask)来改变，返回旧的umask。
	2. 打开
		int open(const char *pathname, int flags);
		int open(const char *pathname, int flags, mode_t mode);

		pathname:需要打开的文件名称，函数路径。
		flags:
			O_RDONLY			以只读的方式打开文件
			O_WRONLY			以只写的方式打开文件
			O_RDWR				以读写的方式打开文件
			O_APPEND			以追加的方式打开文件
			O_CREAT				创建一个文件
			O_EXEC				如果使用了O_CREAT而且文件存在，就会发生一个错误
			O_NOBLOCK			以非阻塞的方式打开一个文件
			O_TRUNC				如果文件存在，则删除文件的内容

		O_RDONLY，O_WRONLY，O_RDWR三个标志只能使用任意一个。
		使用O_CREAT，需要设置mode，用来表示访问权限。
				S_IRUSR 		用户可以读
				S_IWUSR			用户可以写
				S_IXUSR			用户可以执行
				S_IRWXU			用户可以读，写，执行
				S_IRGRP			组可以读
				S_IWGRP
				S_IXGRP
				S_IRWXG
				S_IROTH			其他人可以读
				S_IWOTH
				S_IXOTH
				S_IRWXO
				S_ISUDI			设置用户执行ID
				S_ISGID			设置组的指定ID

	3. 读写
		int read(int fd, const void *buf, size_t length);
		int write(int fd, const void *buf, size_t length);

	4. 定位
		int lseek(int fd, offset_t offset, int whence);
			lseek()将文件读写指针相对whence移动offset个字节，
			SEEK_SET: 相对文件开头
			SEEK_CUR:相对文件读写指针的当前位置
			SEEK_END:相对文件末尾

	5.关闭
		int close(int fd);

	二：C库的使用。
		2.1创建和打开
			FILE *fopen(const char *path, const char *mode);
				mode:
					r,rb		以只读方式
					w,wb		以只写方式打开，如果文件不存在则创建该文件，否则文件被截断
					a,ab		以追加方式打开，如果文件不存在，则创建该文件
					r+,r+b,rb+	以读写方式打开
					w+,w+b,wh+	以读写方式打开，如果文件不存在，创建新文件，否则文件被截断
					a+,a+b,ab+	以读和追加方式打开。如果文件不在，则创建新文件。

		2.2 读写
			int fgetc(FILE *stream);
			int fputc(int c, FILE *stream);
			char *fgets(char *s, int n, FILE *stream);
			int fputs(const char *s, FILE *stream);
			int fprintf(FILE);
			int fscanf(FILE stream, const char format, ...);
			size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
			size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);

			定位函数：
				int fgetpos(FILE *stream, fpos_t *pos);
				int fsetpos(FILE *stream, const fpos_t *pos);
				int fseek(FILE *stream, long offset, int whence);

		2.3	关闭
			fclose(FILE *stream);
	
	三：Linux文件系统和驱动设备
		3.1 查看/proc/devices文件可以获取系统中注册的设备。第一列为主设备号，第2列为次设备号
		3.2 查看/dev目录可以获知系统包含的设备文件，日期的前两列给出了对应设备的主从设备号
		3.3 在linux内核中，分别使用bus_type, device_driver和drvice来描述总线，驱动和设备。三个的结构体定义在include/linux/device.h

4.字符设备
	4.1 cdev结构体
		获取主从设备号:MAJOR(dev_t dev)  MINOR(dev_t dev)
		生成主从设备号：MKDEV(int major, int minor)

	4.2 虚拟文件接口：
		void cdev_init(struct cdev *, struct file_operations *);
		struct cdev *cdev_alloc(void);
		void cdev_put(struct cdev *p);
		int cdev_add(struct cdev *, dev_t , unsigned);
		void cdev_del(struct cdev *);

		cdev_init()函数用于初始化cdev成员，并建立cdev和file_operations之间的连接。
		cdev_alloc()用于动态申请一个cdev内存。
		cdev_add和cdev_del分别向系统贴加和删除一个cdev.完成字符设备的注册和注销。

	4.3 分配和释放设备号
		在调用cdev_add,函数向系统注册字符设备之前，应首先调用register_chrdev_region()或alloc_chrdev_region()函数向系统申请设备号。

	4.4 file_operations结构体：
		主要成员分析：
			1.llseek()函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。
			2.read函数用来从设备读取数据。
			3.write函数向设备发送数据。
			4.readdir函数仅用于目录，设备节点不需要实现。
			5.ioctl提供设备相关的控制命令。
			6.mmap将设备内存映射到进程内存中，如果驱动设备为实现，用户进行mmap将返回错误。帧缓冲设备特别有意义。
			7.poll一般用于询问是否可被非阻塞地立即读写。当询问的条件未触发时，用户空间进行select()和poll()系统调用将引起进程的阻塞。
			8.aio_read和aio_write函数分别对与文件描述符对应的设备进行异步读，写操作，设备实现这两个函数后，用户空间可以对该设备文件描述符调用aio_read, aio_write等系统调用进行读写。

	4.5 内核空间和用户空间的拷贝
			unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);
			unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);

	4.6 复制内存的简单字符
			get_user(val, (int *)arg);
			put_user(val, (int *)arg);

