1,一个Linux内核模块主要由如下几个部分组成。
	1.1 模块加载函数（一般需要）
 		当通过insmod或modprobe 命令加载内核模块时，模块的加载函数会自动被内核执行，完成模块的相关初始化。
	1.2 模块卸载函数（一般需要）
 		当通过rmmod命令卸载模块时，模块的卸载函数会自动内内核执行，完成与模块卸载函数相反的功能。
 	1.3 模块许可证声明(必须)
		许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE,模块被加载时，将收到内核被污染（kernel tainted）的警告。
		MODULE_LINCENSE("Dual BSD/GPL")的语句声明模块采用BSD/GPL双LINCENSE。
	1.4 模块参数（可选）
		模块参数是模块被加载的时候可以被传递给它的值，它本身对应模块内部的全局变量。
	1.5 模块导出符号（可选）
		内核模块可以导出符号（symbol,对应于函数或变量），这样其他模块可以使用本模块中的变量或函数。
	1.6 模块作者等信息声明（可选）

2. Linux2.6 的 “proc/kallsyms”文件对应着内核符号表，它记录了符号以及符号所在的内存地址。
	模块可以使用如下宏到处符号到内核符号表：
	EXPORT_SYMBOL(符号名)；
	EXPORT_SYMBOL_GPL(符号名)；
	导出的符号将可以被其他模块使用，使用前声明一下即可，EXPORT_SYMBOL_GPL()只适用于包含GPL许可权的模块。

3. Linux 的文件系统
	1.创建
		int creat(const char *filename, mode_t mode);
		mode:指定新建文件的存取权限，它同umask一起决定文件的最终权限（mode&umask）
		umask可通过调用 int umask(int newmask)来改变，返回旧的umask。
	2. 打开
		int open(const char *pathname, int flags);
		int open(const char *pathname, int flags, mode_t mode);

		pathname:需要打开的文件名称，函数路径。
		flags:
			O_RDONLY			以只读的方式打开文件
			O_WRONLY			以只写的方式打开文件
			O_RDWR				以读写的方式打开文件
			O_APPEND			以追加的方式打开文件
			O_CREAT				创建一个文件
			O_EXEC				如果使用了O_CREAT而且文件存在，就会发生一个错误
			O_NOBLOCK			以非阻塞的方式打开一个文件
			O_TRUNC				如果文件存在，则删除文件的内容

		O_RDONLY，O_WRONLY，O_RDWR三个标志只能使用任意一个。
		使用O_CREAT，需要设置mode，用来表示访问权限。
				S_IRUSR 		用户可以读
				S_IWUSR			用户可以写
				S_IXUSR			用户可以执行
				S_IRWXU			用户可以读，写，执行
				S_IRGRP			组可以读
				S_IWGRP
				S_IXGRP
				S_IRWXG
				S_IROTH			其他人可以读
				S_IWOTH
				S_IXOTH
				S_IRWXO
				S_ISUDI			设置用户执行ID
				S_ISGID			设置组的指定ID

	3. 读写
		int read(int fd, const void *buf, size_t length);
		int write(int fd, const void *buf, size_t length);

	4. 定位
		int lseek(int fd, offset_t offset, int whence);
			lseek()将文件读写指针相对whence移动offset个字节，
			SEEK_SET: 相对文件开头
			SEEK_CUR:相对文件读写指针的当前位置
			SEEK_END:相对文件末尾

	5.关闭
		int close(int fd);

	二：C库的使用。
		2.1创建和打开
			FILE *fopen(const char *path, const char *mode);
				mode:
					r,rb		以只读方式
					w,wb		以只写方式打开，如果文件不存在则创建该文件，否则文件被截断
					a,ab		以追加方式打开，如果文件不存在，则创建该文件
					r+,r+b,rb+	以读写方式打开
					w+,w+b,wh+	以读写方式打开，如果文件不存在，创建新文件，否则文件被截断
					a+,a+b,ab+	以读和追加方式打开。如果文件不在，则创建新文件。

		2.2 读写
			int fgetc(FILE *stream);
			int fputc(int c, FILE *stream);
			char *fgets(char *s, int n, FILE *stream);
			int fputs(const char *s, FILE *stream);
			int fprintf(FILE);
			int fscanf(FILE stream, const char format, ...);
			size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
			size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);

			定位函数：
				int fgetpos(FILE *stream, fpos_t *pos);
				int fsetpos(FILE *stream, const fpos_t *pos);
				int fseek(FILE *stream, long offset, int whence);

		2.3	关闭
			fclose(FILE *stream);
